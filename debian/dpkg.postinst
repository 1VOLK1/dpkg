#!/bin/sh

set -e

dupdaemonhelp () {
	cat <<EOF

Some daemons and similar services whose scripts have links in the
/etc/rcN.d directories have both start (S) and stop (K) links in
some runlevels.  Thus these services get stopped and immediately
restarted at some runlevel changes, which is probably not what
you want.  I can remove the probably-spurious K links if you like.

Type Y to remove then, N to leave them, or L to list them.
If you don't know what to do you can say N now and then delete
them by hand later.

EOF
}

if [ "x$1" = xconfigure ]; then
	if [ -d /usr/doc -a ! -e /usr/doc/dpkg -a -d /usr/share/doc/dpkg ] ; then
		ln -s ../share/doc/dpkg /usr/doc/dpkg
	fi

	if [ -z "$2" -a ! -f /etc/dpkg/dpkg.cfg ] ; then
		cp /usr/share/doc/dpkg/dpkg.cfg /etc/dpkg
	fi

	case "$2" in
	0.* | 1.0.* | 1.1.0 | 1.1.0[^0-9]* | '' )
		for f in 0 1 2 3 4 5 6
		do
			cd /etc/rc$f.d
			for g in K[0-9][0-9]*
			do
				if [ -n "`echo \"x$g\" | tr -d 0-9A-Za-z_-`" ]
				then
					continue
				fi
				h="`echo $g | sed -e 's/^K/S/'`"
				if ! [ -L $h -a -L $g ] \
				  || [ "`ls -Li $g 2>/dev/null | awk '{print $1}'`" != \
				       "`ls -Li $h 2>/dev/null | awk '{print $1}'`" ]
				then
					continue
				fi
				removes="$removes rc$f.d/$g"
			done
		done
		if [ -n "$removes" ]
		then
			cd /etc
			dupdaemonhelp
			while [ -n "$removes" ]
			do
				echo -n 'y=remove, n=leave, l=list, h=help ?  '
				read response
				case "$response" in
				[Yy]*)
					echo "Removing duplicate K links ..."
					rm -v $removes
					removes=""
					;;
				[Nn]*)
					echo -e "OK, leaving them.\n"
					removes=""
					;;
				[Ll]*)
					echo
					echo $removes
					echo
					;;
				[Hh]*)
					dupdaemonhelp
					;;
				esac
			done
		fi
		;;
	1.1.6 | 1.1.6elf | 1.2.[0123] | 1.2.[0123]elf )
		response=''
		while [ -z "$response" ]; do
			echo -n '
The version of dpkg you'\''re upgrading from had a problem with the
install-info program used to maintain the /usr/info/dir file.  It may
have corrupted the file, for example by placing new entries for the
menu in it before the `* Menu'\'' line (thus making them ineffective) or
by creating several identical sections.

I can try to sort these problems out, but beware that this process is
not guaranteed not to mess up a dir file which has things that look
like menu entries in the introductory paragraphs.  The distributed dir
files do not do this, so if you haven'\''t edited /usr/info/dir it'\''s
almost certainly safe to say `yes'\'' to the next question.

If you say `no'\'' you may wish to check and/or edit /usr/info/dir yourself.

Try to check/repair /usr/info/dir automatically ?  [y/n]  '
			read response
			case "$response" in
			[Yy]* | '')	response=yes ;;
			[Nn]*)		response=no ;;
			*)		response='' ;;
			esac
		done
		if [ "$response" = yes ]; then
			echo "
Checking/repairing /usr/info/dir ..."
			cleanup-info --unsafe
			echo
		else
			echo "
OK.
"
		fi
		;;
	esac
fi

if [ -d /usr/doc -a ! -e /usr/doc/dpkg -a -d /usr/share/doc/dpkg ] ; then
	ln -s ../share/doc/dpkg /usr/doc/dpkg
fi


if [ -f /usr/info/dir ] ; then
	echo "Moving /usr/info/dir to /usr/share/info/dir, and creating /usr/info/dir symlink."
	cp -a /usr/info/dir /usr/share/info/dir
	ln -f ../share/info/dir /usr/info/dir
fi


cd /var/lib/dpkg
for f in diversions statoverride status ; do
	if [ ! -f "$f" ] ; then
		touch "$f"
	fi
done

